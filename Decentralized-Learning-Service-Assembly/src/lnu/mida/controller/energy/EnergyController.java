/*
 * Copyright (c) 2012, 2014 Moreno Marzolla
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */

package lnu.mida.controller.energy;

import com.lajv.location.Location;
import lnu.mida.entity.GeneralNode;
import lnu.mida.protocol.OverloadApplication;
import lnu.mida.protocol.OverloadComponentAssembly;
import peersim.config.*;
import peersim.core.*;

public class EnergyController implements Control {

	// ///////////////////////////////////////////////////////////////////////
	// Constants
	// ///////////////////////////////////////////////////////////////////////

	/**
	 * The component assambly protocol.
	 */
	private static final String VIV_PROT = "viv_prot";

	/**
	 * The component assambly protocol.
	 */
	private static final String COMP_PROT = "comp_prot";

	/**
	 * The application protocol.
	 */
	private static final String APPL_PROT = "appl_prot";

	// ///////////////////////////////////////////////////////////////////////
	// Fields
	// ///////////////////////////////////////////////////////////////////////

	/**
	 * The name of this observer in the configuration file. Initialized by the
	 * constructor parameter.
	 */
	private final String name;

	private final int vivaldi_pid;
	private final int component_assembly_pid;
	private final int application_pid;

	public static int failed_connections;
	public static int number_of_experiences;
	public static double total_experiences_value;

	public static double variance;
	public static double stdDev;

	// ///////////////////////////////////////////////////////////////////////
	// Constructor
	// ///////////////////////////////////////////////////////////////////////
	/**
	 * Standard constructor that reads the configuration parameters. Invoked by the
	 * simulation engine.
	 * 
	 * @param name the configuration prefix for this class.
	 */
	public EnergyController(String name) { 
		this.name = name;
		vivaldi_pid = Configuration.getPid(name + "." + VIV_PROT);
		component_assembly_pid = Configuration.getPid(name + "." + COMP_PROT);
		application_pid = Configuration.getPid(name + "." + APPL_PROT);
	}

	// ///////////////////////////////////////////////////////////////////////
	// Methods
	// ///////////////////////////////////////////////////////////////////////

	@Override
	public boolean execute() {

		// non calcolo al round 0 (nessun bind)
		if (CommonState.getIntTime() == 0)
			return false;

		int notResolved = 0;

		// For every node calculate the energy consumed after an assembly
		// Energy consumption = computation energy + communication energy

		for (int i = 0; i < Network.size(); i++) {

			if (!Network.get(i).isUp()) {
				continue;
			}

			GeneralNode node = (GeneralNode) Network.get(i);
			OverloadComponentAssembly ca = (OverloadComponentAssembly) node.getProtocol(component_assembly_pid);
			OverloadApplication appl = (OverloadApplication) node.getProtocol(application_pid);
			
			ca.updateLambdaTot();
			
			double consumedIndividualCommunicationEnergy = 0;
			double consumedIndividualCPUEnergy = 0;

			
			double consumedIndividualCommunicationEnergyLambda = 0;
			double consumedIndividualCPUEnergyLamda = 0;

//			System.out.println("node="+node.getID()+" type="+ca.getType()+" ha lambda="+ca.getLambda_t());

			if (!ca.isFullyResolved()) {
				continue;
			} else {

				
				// Computation energy consumption generated by service S on hosting node
				consumedIndividualCPUEnergyLamda = node.getConsumedIndividualCPUEnergy(ca.getLambdatoCPU());
				consumedIndividualCPUEnergy = node.getConsumedIndividualCPUEnergy(1);
				
				// Communication energy in reception for single request
				consumedIndividualCommunicationEnergy+=node.getConsumedIndividualCommEnergyReceiving(1);
				
				consumedIndividualCommunicationEnergyLambda+=node.getConsumedIndividualCommEnergyReceiving(ca.getLambda_t());

				
				
				OverloadComponentAssembly[] listDepObj = ca.getDependencies_obj();
				boolean[] listDep = ca.getDependencies();
				for (int j = 0; j < listDep.length; j++) {

					boolean dep = listDep[j];
					if (dep == true) {

						OverloadComponentAssembly depObj = listDepObj[j];

						GeneralNode receiverNode = GeneralNode.getNode(depObj.getId());

						/**
						 * Control things that should not happen
						 */
						if (ca.getType() == depObj.getType()) {
							System.err.println("Cannot have dependency on same type: Energy Controller");
							System.exit(0);
						}

						if (node.getID() == depObj.getId()) {
							System.err.println("Cannot have dependency on same node: Energy Controller");
							System.exit(0);
						}

						if (ca.getId() != node.getID()) {
							System.err.println("CA and Node must have same ID");
							System.exit(0);
						}

						if (depObj.getId() != receiverNode.getID()) {
							System.err.println("depObj and receiverNode must have same ID " + depObj.getId() + " "
									+ receiverNode.getID());
							System.exit(0);
						}

						/**
						 * 
						 */

						// System.out.println("Distance between "+node.getID()+" "+depObj.getId()+"
						// "+senderLoc.latency(receiverLoc)+" "+receiverLoc.latency(senderLoc));
						
						
						// Communication energy consumption (DO NOT confuse real latency
						// (n1.location.latency(n2.location)) and estimated latency
						// (vp1.vivCoord.distance(vp2.vivCoord)):
						// Communication energy = sending energy + receiving energy


						Location senderLoc = node.getLocation();
						Location receiverLoc = receiverNode.getLocation();
						double latency = senderLoc.latency(receiverLoc);

						double lambda_to_receiver = ca.getTransferFunctions()[depObj.getType()].calculate_tSd(ca.getLambda_t());
						
						
						consumedIndividualCommunicationEnergyLambda+=node.getConsumedIndividualCommEnergySending(lambda_to_receiver, latency);
						
						consumedIndividualCommunicationEnergy+=node.getConsumedIndividualCommEnergySending(1, latency);

					}
				}			
			}
			
			// single request
			node.setI_comp(consumedIndividualCPUEnergy);
			node.setI_comm(consumedIndividualCommunicationEnergy);
			
			// lambda dependent
			node.setI_comp_lambda(consumedIndividualCPUEnergyLamda);
			node.setI_comm_lambda(consumedIndividualCommunicationEnergyLambda);

		}
		return false;
	}

	public static double getVariance() {
		return variance;
	}

	public static double getStdDev() {
		return stdDev;
	}

}
